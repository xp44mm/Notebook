# Part 2 Observables in practice

Now that you understand the basics of RxJS observables and you're starting to become familiar with the syntactic style of the library, it's time to kick it up a notch and dive into some more-interesting use cases. In chapter 5, we'll examine nested observables, or streams within streams, and their ability to create more-powerful semantics for asynchronous control. Chapter 6 starts by dismantling the observable lifecycle and explaining how you can make use of different parts of the observable's life to manage state logic without exposing such state externally. Chapter 6 follows this with a discussion of how you can combine several observables and combine multiple events occurring at different times. In chapter 7, you'll learn about how observables manage exceptions neatly and allow you to program based on happy-path expectations, beginning with a functional programming introduction to the `Try` data type.