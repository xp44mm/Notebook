编译原理：

第一级解析，充分利用现代库成熟的功能，包括正则表达式和字符串操作函数。而非使用yacc的lex分析器。将字符分组，并确定每组的类型。

第二级，对第一级的结果，非嵌套的进行DFA分组。正则表达式应用于token type。

编译过程分为4部：

1. 用正则表达式
2. 用lex
3. 用yacc

正则表达式的运算是一元，二元。没有多元的。

正则表达式->NFA->DFA

NFA由正则表达式转换而成，可以叫做正则NFA，他有如下特点：

状态号是自然数。

状态号由小到大，且连续。

只有一个开始状态，只有一个接受状态。

正则NFA的开始状态是零，接受状态是最大数值。

根据状态的规模，无符号32位整数足够包括所有状态。

开始状态，输入字符，结束状态。组成三元组表示一条边，此三元组的值是唯一的，在NFA表中不重复。

边与边的先后顺序无关紧要。

NFA表是个Set集合。其中每元素是一条边。

正则NFA至少有一条边。至少两个节点。至少一个字符。

NFA先行结合，再结合后的每一行结合，最后整个词法分析器的NFA。

DFA死状态一定是一个线段的终点，不可能是起点。



文法，产生式的各种性质：

增广语法的新开始符号为`String.empty`。

用记录类型替代类类型。

kernel -> closure的算法带向前看符号

状态，语法符号，

LR表先假设其存在冲突，为歧义表。至少1个查询值，一个以上的查询值，则用优先级排除。

用集合中的索引号代表记录。

kernel的向前看符号，当作为索引时，省略向前看符号集合。当进行`closure`，`goto`推导时应该带上向前看符号。

查询表的值为元素的集合表示歧义表，查询值为普通元素的为确定表。确定表是歧义表的特殊情况，歧义值的集合中有且只有一个元素值。

优先级：高优先级数值更大，先于低优先级计算。比如乘号优先级高于加号。一元运算符优先级高于二元运算符，二元运算符优先级高于三元运算符。

优先级数值可以类比为山的高度，顶部行的优先级数值大。

lexical analyzer由lex生成

yacc parser 由 yacc生成

第一个产生式头是开始符号。

In Yacc, an empty alternative, as the third line is, denotes $\epsilon$.

a follow b -> ba

a followed by b -> ab

语义动作是生成一个语法树。

避免r/r冲突的例子：

`ls(0)`是函数调用还是数组的索引？

`sum(1,2,,,,)`参数可以为空的情况？

不要使用空格作为运算符。

所有冲突都要显式明确的给出规则解决，不会静默解决。

冲突中的产生式，和终结符号才需要列出优先级。优先级相对比较大小，绝对值无意义。

优先级可以解决移动/归纳冲突，不能解决其他冲突，需要修改语法。

不要把复杂性都推给解析器，在分词阶段产生更结构化的序列。降低解析难度。

比如，两个字符`ab`连续表示连接，我们可以在中间补充连接运算符`a@b`。

lex文件说明：

叶子节点，叶子节点是一个字符串字面量。当其中内容符合`/\w+/`时，可以省略引号。

正则表达式的用途：

合并有限深度的多个元素：比如,excel引用由三个部分组成sheet!x1，且每个部分都是叶节点。比如正则定义由三个部分组成为{id}，且每个部分都是叶节点。

补充缺省符号或值：补充缺省符号可以减少歧义，降低语法解析的难度。比如JavaScript补充行尾分号。比如在多项式，将省略的乘号补充。正则表达式的字符连接运算符用@运算符表示。

