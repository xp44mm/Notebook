# 反射随笔

## 对象解包成泛型容器

强类型语言，比如F#，有时将类型包装成`obj`传递。接受`obj`的对象并不知道该实例是什么类型的。尽管可以使用`obj.GetType()`运行时获取类型信息。比如：

```F#
let num = if obj.GetType() = typeof<int> then obj :> int else 0
```

当类型是泛型时，这个方法：

```
let obj = box [20;24]
let ages = obj :?> list<int>
```

没有问题。一般情况下，当我们写代码时，是不知道列表元素的具体类型，可能元素类型有很多种，用这个方法：

```F#
let ages = obj :?> list<obj>
```

会报错：

`InvalidCastException`: 无法将类型为“FSharpList\`1[Int32]”的对象强制转换为类型“FSharpList\`1[Object]”。

上面的方法过于简单粗暴，而通过`Type`对象实例获得的泛型参数的类型对象实例并没有太大的用处。

正确的方法是动态调用`List`类型中的成员，重新克隆一个`list<obj>`类型的实例：

```F#
let rec unboxList (lst:obj) =
    [
        if lst?IsEmpty then
            ()
        else
            yield lst?Head
            yield! unboxList lst?Tail
    ]
```

当泛型定义的类型已经给定，要处理不同类型的泛型参数时，就用这种方法。在这个例子中，确定的类型定义是`list<>`，类型参数不确定，被当作`obj`处理。函数返回`list<obj>`类型。问题解决。这里用到的操作符`?`是动态调用操作符，来自《Expert F# 4.0》Using the F# Dynamic Reflection Operators一节。

```F#
open System.Reflection
let (?) (obj : obj) (nm : string) : 'T =
    obj.GetType().InvokeMember(nm, BindingFlags.GetProperty, null, obj, [||])
    |> unbox<'T>
```

## 可区分联合

内置的可区分联合的用例与其联合一样同属一个类型，比如：

```F#
[<Fact>]
member this.``option属于哪个联合``() =
  let t1 = typeof<option<obj>>
  let x = Some 10 |> box
  let t2 = x.GetType()//.BaseType

  for t in [t1;t2] do
      output.WriteLine(t.Name)
      output.WriteLine(sprintf "%b" <| FSharpType.IsUnion t)

  Assert.Equal(t1.GetGenericTypeDefinition(),t2.GetGenericTypeDefinition())
```

是通过的。其他内置可区分联合的类型是否相同还需测试。

自定义可区分联合用例的类型，是可区分联合类型的一个子类型。

```F#
[<Fact>]
member this.``可区分联合用例是联合的子类型``() =
  let t0 = typeof<Hierarchy<obj>>
  let x = Scalar 10 |> box
  let t1 = x.GetType().BaseType

  for t in [t0;t1] do
      output.WriteLine(t.Name)
      output.WriteLine(sprintf "%b" <| FSharpType.IsUnion t)
  Assert.Equal(t0.GetGenericTypeDefinition(),t1.GetGenericTypeDefinition())
```

